## 问答作业

### 1. **SV39 页表页表项的组成及标志位作用**

SV39 是 RISC-V 架构中的一种虚拟地址空间划分方案，它采用了 39 位虚拟地址来映射物理地址。SV39 页表由三个层次组成，分别是：页全局目录（PGD）、页上级目录（PUD）、页表（PTE），并且每一层都有其对应的页表项（PTE）。

每个页表项（PTE）的组成如下：

- **物理页框号**（Physical Page Frame Number，PPN）：指定物理页框的地址，通常占 44 位（对于 64 位系统）。
- **V (Valid)**：有效位，指示当前页表项是否有效。有效则代表该页在内存中存在，否则发生缺页异常。
- **R (Readable)**：可读位，指示该页是否可以被读取。如果不设置此位，进程访问此页时会发生异常。
- **W (Writable)**：可写位，指示该页是否可写。如果此位不设置，进程对该页的写操作会触发异常。
- **X (Executable)**：可执行位，指示该页是否可以执行。如果不设置此位，进程在尝试执行该页的内容时会触发异常。
- **U (User)**：用户模式位，指示该页是否可被用户态访问。如果此位不设置，只有内核态可以访问此页。
- **D (Dirty)**：脏位，通常在写时设置，用来表示该页自上次加载以来是否被修改。
- **A (Accessed)**：访问位，表示该页是否被访问过。操作系统可以使用该位来进行页面替换算法等操作。
- **G (Global)**：全局位，指示该页表项是否在TLB（Translation Lookaside Buffer）中被缓存，即在不同的上下文中是否共享该页表项。

### 2. **缺页可能导致的异常**

缺页通常会导致以下异常：

- **Page Fault（缺页异常）**：访问的页面不在物理内存中（例如未加载的页面或已被换出），触发缺页异常。
- **Protection Fault（保护异常）**：访问一个页面时，违反了该页面的权限（如在只读页面上执行写操作）。
- **Misaligned Access（未对齐访问）**：访问一个未对齐的地址（例如试图访问 4 字节对齐的地址时使用了非 4 字节对齐的访问）。

### 3. **发生缺页时，相关重要寄存器的值**

发生缺页时，操作系统会得到一个中断或异常。相关的寄存器值通常包括：

- **异常发生时的虚拟地址**：MMU 会将当前访问的虚拟地址提供给操作系统，以便它能决定如何处理。
- **异常原因**：会提供有关缺页的具体原因，例如是否是无效页表项、权限错误等。
- **控制寄存器**：如 `sstatus`、`stvec` 等，记录了当前的执行状态和中断向量的指针。

### 4. **Lazy 策略的好处**

Lazy 策略（懒加载）即在进程第一次访问某个页面时才将其加载到内存中。其主要好处有：

- **节省内存**：避免了一开始就加载整个程序或整个内存空间，减少了内存的占用。
- **提高性能**：对于程序来说，大多数时候它并不需要访问所有分配的内存区域，因此，按需加载可以减少不必要的内存访问。
- **提升启动速度**：避免了大量不必要的磁盘访问，程序可以更快启动。

### 5. **处理 10G 连续内存页面的 SV39 页表占用内存估算**

假设一个进程申请了 10GB 的内存，且使用的是 SV39 页表，且每个页表项为 8 字节（64 位），那么：

- 每个页表可以管理 4KB 的内存，因此 10GB = 10 * 1024 * 1024 KB / 4KB = 2,621,440 个页表项。
- 假设需要三层页表（PGD、PUD、PTE），每层页表有 512 项，因此：
  - 第一层：每个页表占用 8 * 512 = 4096 字节（即 4KB）。
  - 第二层：每个页表占用 8 * 512 = 4KB。
  - 第三层：每个页表占用 8 * 512 = 4KB。

因此，整个 10GB 内存的页表大致占用的内存量是：
- **4096 页表项 × 4KB** = 16MB （每层页表占用的内存大小）
- 总体占用内存：16MB * 3 = **48MB**

### 6. **实现 Lazy 策略及缺页处理**

要实现 Lazy 策略，操作系统需要在进程访问未加载的内存页时，触发缺页异常。在缺页异常发生时，操作系统需要：

1. 确认页面是否真的需要加载。
2. 从磁盘或其他存储介质中加载该页面。
3. 更新页表项，标记为有效并设置合适的访问权限。
4. 重新执行导致缺页的指令。

### 7. **Swap 策略与页表项失效**

当页面被换出内存到磁盘时，页表项通常会被设置为无效。具体来说：

- 页表项的 **V (Valid)** 位会被清除，表示该页不再有效。
- 页表项的 **P (Present)** 位也会被清除，指示该页的物理内存不在当前的物理内存中，而是在磁盘上。

### 8. **单页表与双页表**

#### 单页表

在单页表设计下，用户空间和内核空间共享同一页表。此时，操作系统需要通过硬件机制（如页表基址寄存器）区分用户态和内核态的访问权限。

##### 如何更换页表

操作系统通过更新 `satp`（Supervisory Address Translation and Protection）寄存器中的页表基址来更换页表。

##### 如何控制用户态无法访问内核页面

在单页表设计下，操作系统通过设置权限位（如 `U` 位）来确保用户态进程无法访问内核空间。例如，内核页面的页表项会设置 `U = 0`，用户进程无法访问这些页。

#### 双页表

双页表使用两张不同的页表，一张用于用户空间，一张用于内核空间。在这种情况下，切换页表时，只需要切换到对应的用户页表或内核页表。

##### 何时需要更换页表

当进程切换到用户态时，操作系统会切换到用户页表；当进程切换到内核态时，操作系统会切换到内核页表。此时，操作系统只需要更新 `satp` 寄存器来完成页表的切换。

### 9. **单页表的优势**

单页表的优势在于设计简单，管理开销较小，因为只有一张页表需要维护。但其缺点是，如果不当设计，可能会造成用户和内核空间之间的权限管理复杂性增加。

### 10. **双页表下的页表更换**

在双页表系统中，通常会在用户态和内核态之间进行切换时更换页表。例如：

- 当用户进程从用户态切换到内核态时，需要更换页表并切换到内核页表。
- 当操作系统处理完内核请求后，返回用户态时，又需要切换回用户页表。

## 实验报告

在本次实验中，完成了 sys_mmap 和 sys_munmap 系统调用的实现。sys_mmap 实现了内存区域的映射，并通过参数 port 设置内存访问权限。sys_munmap 则提供了取消映射功能，确保内存管理的正确性。主要的挑战在于处理页对齐、映射权限检查、以及页表的更新。同时，针对物理内存不足和无效映射等异常情况进行了错误处理。

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

    《你交流的对象说明》

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

    《你参考的资料说明》

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。

