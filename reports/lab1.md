## 简答作业
### 1. **正确进入 U 态后的程序特征：**

在正确进入 U 态（用户态）后，程序将运行在一个受限的环境中，具有以下特征：

- 不能使用 S 态（Supervisor）特权指令，例如 `csrw`，如果在 U 态下尝试执行这些指令，程序将触发异常。
- 无法直接访问 S 态的寄存器（例如 `sstatus`、`sepc` 等），如果尝试访问，会触发异常。

通过运行三个 `bad` 测例（`ch2b_bad_*.rs`），可以验证这些特征。每个 `bad` 测例通常会故意执行不允许的操作，例如使用特权指令或访问特权寄存器，然后触发 trap 异常。具体行为可能包括：

- 报告非法指令异常（Illegal Instruction）。
- 触发不合法的内存访问（可能由于尝试访问特权寄存器）。
  
测试过程中使用的 SBI（Supervisor Binary Interface）的版本应注明，以便参考异常处理行为的差异。假设使用的 SBI 版本是 **riscv-sbi v0.3**。

### 2. **深入理解 `trap.S` 中两个函数 `__alltraps` 和 `__restore`：**

#### L40：刚进入 `__restore` 时，a0 代表了什么值？

进入 `__restore` 时，`a0` 通常存储的是一个指向内核任务或中断处理程序保存的上下文信息的指针。在任务切换或中断返回时，`a0` 负责保存寄存器的恢复地址，确保从正确的上下文切换回去。

`__restore` 的两种使用场景：
1. **任务切换恢复**：用于在从内核态切换回用户态之前恢复任务的上下文。
2. **中断返回恢复**：处理完中断后，恢复中断前保存的用户态任务的上下文。

#### L43-L48：这些汇编代码特殊处理了哪些寄存器？这些寄存器的值对于进入用户态有何意义？请分别解释。

```asm
ld t0, 32*8(sp)
ld t1, 33*8(sp)
ld t2, 2*8(sp)
csrw sstatus, t0
csrw sepc, t1
csrw sscratch, t2
```

- **`sstatus`（通过 `t0`）**：恢复 S 态状态寄存器，它决定了特权级别和是否启用中断。在从 S 态切换到 U 态时，`sstatus` 设置用户模式的执行环境，特别是 `SPP` 位（Supervisor Previous Privilege），应设为 U 态。
- **`sepc`（通过 `t1`）**：恢复程序计数器寄存器，它存储了用户态程序的下一条要执行的指令地址。
- **`sscratch`（通过 `t2`）**：临时寄存器用于保存任务切换时的栈指针信息。在从 S 态返回到 U 态时，`sscratch` 恢复 U 态的栈指针。

这些寄存器确保从 S 态切换回 U 态时，用户程序能够在正确的环境下继续执行。

#### L50-L56：为何跳过了 x2 和 x4？

`x2` 是栈指针（`sp`），它的恢复使用了特殊处理，因为栈指针的值会影响任务切换时的栈管理。而 `x4` 是全局寄存器（`tp`），通常保存线程局部存储指针，跳过是因为它的恢复可能在其他地方单独处理。

#### L60：该指令之后，sp 和 sscratch 中的值分别有什么意义？

```asm
csrrw sp, sscratch, sp
```

这条指令交换了 `sp`（栈指针）和 `sscratch` 的值：

- **`sp`**：保存从 S 态切换到 U 态的任务的栈指针。
- **`sscratch`**：被用于存储内核态的栈指针，在之后的 trap 发生时，内核可以通过 `sscratch` 找回自己的栈。

此交换在任务切换和 trap 返回时起到关键作用，确保内核态和用户态栈的正确使用。

#### `__restore` 中发生状态切换的指令是：

```asm
sret
```

这条指令会根据 `sstatus` 寄存器中的 `SPP` 位决定是否返回到 U 态。当 `SPP` 位为 0 时，`sret` 会将控制权交回到用户态，从而触发用户态执行。

#### L13：该指令之后，sp 和 sscratch 中的值分别有什么意义？

```asm
csrrw sp, sscratch, sp
```

这条指令执行后：

- **`sp`**：保存了当前内核态的栈指针。
- **`sscratch`**：保存了任务的 U 态栈指针，用于任务切换。

#### 从 U 态进入 S 态是哪一条指令发生的？

从 U 态进入 S 态的状态切换通常发生在触发异常或中断时。最常见的指令是：

```asm
ecall
```
## 实验报告

在本次实验中，完成了 sys_task_info 系统调用的实现。该系统调用查询当前正在执行任务的信息，包括任务状态、系统调用次数以及任务运行时长。系统调用次数通过任务控制块中的 syscall_count 数组进行维护，运行时长则通过任务控制块中的 start_time 字段计算。实现过程中，关键的挑战是如何高效地维护每个任务的系统调用信息以及计算任务的运行时间。通过扩展任务控制块和改进系统调用的处理流程，确保了信息的准确性和高效查询。

## 荣誉准则
1.在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

2.此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。